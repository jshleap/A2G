#!/usr/bin/env python

from itertools import islice

from mpi4py import MPI
from pyfaidx import Fasta
from termcolor import colored

from A2G.__version__ import version
from A2G.align2consensus import *


def split_n_yield(fasta, chunks):
    fa = Fasta(fasta)
    n_items = int(np.ceil(len(fa.items()) / chunks))
    it = iter(fa.items())
    piece = list(islice(it, n_items))
    while piece:
        yield '\n'.join(['>%s/n%s' % (sq[1].long_name, sq[1]) for sq in piece])
        piece = list(islice(it, n_items))


comm = MPI.COMM_WORLD
size = comm.Get_size()
rank = comm.Get_rank()

if rank == 0:
    print('\nA2G_mpi version:', colored(version, None, attrs=["bold", "blink"]))
    print(colored('Copyright 2020', 'red', attrs=["bold"]), 'Jose Sergio Hleap\n')
    print("-" * 78)
    print(" Running on %d cores" % size)
    print("-" * 78)

parser = argparse.ArgumentParser()
parser.add_argument('global_consensus', help='Sequence consensus of the '
                                             'global region, e.g. full COI')
parser.add_argument('local_consensus',
                    help='Sequence consensus of the local region, e.g. '
                         'Leray fragment')
parser.add_argument('fasta', help='fasta file with the focal sequences')
parser.add_argument('--out_prefix', action='store', default='A2G_aln',
                    help='Prefix of outputs')
parser.add_argument('--remove_duplicates', action='store_false',
                    help='Keep or remove duplicated sequences',
                    default=True)

args = parser.parse_args()

aln = Align(gene_consensus=args.global_consensus,
            amplicon_consensus=args.local_consensus, no_write=True,
            out_prefix=args.out_prefix)

if rank == 0:
    data = list(split_n_yield(args.fasta, size))
    # data = list(zip(fasta, cycle([aln])))
else:
    data = None

data = comm.scatter(data, root=0)
results = []
for idx, job in enumerate(data):
    aln.out_prefix = '%s_%s' % (args.out_prefix, idx)
    print(job)
    aln.query = job
    results.append(aln.run())

# Gather results on rank 0.
results = comm.gather(results, root=0)

if comm.rank == 0:
    # Flatten list of lists.
    results = [_i for temp in results for _i in temp]
    fasta, subset = zip(*results)
    with open('%s_aligned.fasta' % args.out_prefix, 'w') as o, open(
            '%s_aligned.withoutliers' % args.out_prefix, 'w') as w:
        o.write('\n'.join(fasta))
        w.write('\n'.join(subset))
